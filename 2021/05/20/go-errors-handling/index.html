<!DOCTYPE html><html lang="zh-CN"><head><title>Go Errors Handling</title><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=0.5"><link rel="icon" type="image/svg+xml" href="/favicon.svg"><link rel="stylesheet" href="/css/highlight/xcode.min.css"><link rel="stylesheet" href="/css/bootstrap/bootstrap-tooltips.css"><link rel="stylesheet" href="/css/post.css"><script src="/js/jquery.min.js"></script><meta name="generator" content="Hexo 5.2.0"></head><body><script>if (/mobile/i.test(navigator.userAgent) || /android/i.test(navigator.userAgent)) {
  document.body.classList.add('mobile')
}</script><div><div class="inner"><h2>Go Errors Handling</h2><p>如何正确而优雅地处理错误是每个 Go 程序员都要思考的一个问题。Go 处理错误的方式不同于主流语言，不像 Java 使用 <code>try catch finally</code> 语句去处理程序的异常/错误，Go 中没有这样的错误处理语句。</p>
<p>在 Go 中，错误处理意味着检查错误值并做出决定，Go 错误处理的精髓是基于其以下语言特性：</p>
<a id="more"></a>

<ol>
<li>errors are values。在 Go 中错误就是值，就像 <code>&quot;hello world&quot;</code> 之于 <code>string</code>，我们使用变量去承载错误。Go 用户必须检查函数返回的错误的值，结合 <code>if else</code> 或者 <code>switch case</code> 语句去做流程控制（终止程序执行流程、继续执行流程）；</li>
<li>函数可以有多个返回值，如果函数要返回错误，那么最佳实践是把错误放在多个返回值中的最后一个，形如这个函数签名：<code>func func1() (int, int, error)</code>。这一点非常显而易见，以至于很多人常常忽略掉这个特性在错误处理中的存在。</li>
</ol>
<p>这也是其它语言的用户使用 Go 语言时经常谈到的（好的、坏的），有人会认为这种处理方式导致代码里有太多繁琐的、重复的 <code>if err ≠ nil &#123;&#125;</code>。关于如何处理错误的讨论有很多，这个话题也成为了很多演讲者的演讲主题。本文由浅入深，总结一下错误处理的经验。</p>
<h2 id="Error-的处理策略"><a href="#Error-的处理策略" class="headerlink" title="Error 的处理策略"></a>Error 的处理策略</h2><p>Go 代码中常见的错误处理策略有三种：</p>
<ol>
<li>Sentinel errors</li>
<li>Error types</li>
<li>Opaque errors</li>
</ol>
<p>接下来我将一一介绍它们，描述各自的优缺点，最后总结出一个我愿意在项目中使用的错误处理实践。</p>
<h2 id="Sentinel-errors"><a href="#Sentinel-errors" class="headerlink" title="Sentinel errors"></a>Sentinel errors</h2><p>预定义的、值等于特定值的错误，称为 sentinel errors。它的工作原理是当我们得到一个错误值，拿它跟目标 sentinel error 做等值比较：</p>
<pre><code class="go">package a

// 定义 sentinal error，一般是导出的
var SomeError = errors.New(&quot;something bad happened&quot;)

// someFunc 是一个任意函数，它可能会返回 SomeError
func someFunc() error &#123;
    var expect, got int
    // 经过一系列处理...
    if a != b &#123;
        return SomeError
    &#125;
    // ...
    return nil
&#125;

// ====== 分割线 ======

package b

import &quot;a&quot;

// someFunc 的调用方关心得到的 err 是不是 SomeError，因此需要做一个等值比较
err := someFunc()
if err == SomeError &#123;
    // 如果是 SomeError，那么做一些处理
&#125;</code></pre>
<p>Sentinel errors 是最不灵活的错误处理策略，因为调用方必须使用 <code>==</code> 将结果与预先声明的值进行比较。当你想要提供更多的上下文时，这就出现问题，因为返回一个不同的错误值将破坏现有的相等性检查。甚至是一些有意义的 <code>fmt.Errorf()</code> 携带一些上下文，也会破坏调用者的 <code>==</code>，调用者将被迫查看 <code>error.Error()</code> 方法的输出，以查看它是否跟特定的字符串匹配。但我们不应该依赖检测 <code>error.Error()</code> 的输出，<code>error.Error()</code>方法存在于 <code>error</code> 接口主要用户方便程序员使用，而不是程序。这个输出的字符串只是用来方便用户记录日志、输出到 stdout 等。</p>
<p>Sentinel errors 的弊端：</p>
<ol>
<li>Sentinel errors 成为了你 API 的公共部分。如果你的公共函数或方法返回一个特定值的错误，那么该值必须是公共的，当然要有文档记录，增加了 API 的表面积。如果 API 定义了一个返回特定错误的 <code>interface</code>，则该接口的所有实现都将被限制为返回该错误，即使它们可以提供更具描述性的错误。比如 <code>io.Reader</code>，像 <code>io.Copy</code> 这类函数需要 <code>reader</code> 的实现者比如返回 <code>io.EOF</code> 来告诉调用者没有更多数据了，但这又不是错误。</li>
<li>Sentinel errors 在两个包之间创建了依赖。Sentinel errors 最糟糕的问题是它们在两个包之间创建了源代码依赖关系。例如，检查错误是否等于 <code>io.EOF</code> ，你的代码必须导入 <code>io</code> 包。这个特定的例子听起来并不那么糟糕，因为它非常常见，但是想象一下，当项目中的许多包导出错误值时，包与包之间存在耦合，项目中的其他包必须导入这些错误值才能检查特定的错误条件。</li>
</ol>
<p>结论：尽可能避免 sentinel errors。我的建议是避免在编写的代码中使用 sentinel errors。在标准库中有一些使用它们的情况，但这不是一个我们应该模仿的模式。</p>
<h2 id="Error-types"><a href="#Error-types" class="headerlink" title="Error types"></a>Error types</h2><p>Error types 是实现了 error 接口的自定义类型，例如：</p>
<pre><code class="go">type MyError struct &#123;
    Msg  string
    File string
    Line int
&#125;

func (e *MyError) Error() string &#123;
    return fmt.Sprintf(&quot;%s:%d:%s&quot;, e.File, e.Line, e.Msg)
&#125;

func test() error &#123;
    return &amp;MyError&#123;&quot;Something happened&quot;, &quot;server.go&quot;, 42&#125;
&#125;</code></pre>
<p>因为 <code>MyError</code> 是一个 type，调用者可以使用断言转换成这个类型，来获取更多的上下文信息：</p>
<pre><code class="go">func main() &#123;
    err := test()
    switch err := err.(type) &#123;
        case nil:
            // call succeeded, nothing to do
        case *MyError:
            fmt.Println(&quot;error occurred on line: &quot;, err.line)
        default:
            // unknown error
    &#125;
&#125;</code></pre>
<p>Error types 解决了 sentinel errors 的一个问题，带来了以下改进：</p>
<ol>
<li>错误的上下文信息更丰富。而 sentinel error 的值是固定的，在程序启动的时候已经初始化，基本没有上下文信息，只是一个“哨兵“；</li>
</ol>
<p>一个不错的例子是 <code>os.PathError</code>，它提供了底层执行了什么操作、哪个路径出了问题：</p>
<pre><code class="go">// PathError records an error and the operation and file path that caused it.
type PathError struct &#123;
    Op   string
    Path string
    Err  error
&#125;

func (e *PathError) Error() string &#123; return e.Op + &quot; &quot; + e.Path + &quot;: &quot; + e.Err.Error() &#125;

func (e *PathError) Unwrap() error &#123; return e.Err &#125;</code></pre>
<p>虽然 error types 为错误提供详细的上下文信息，当仍然存在问题：调用者需要使用类型断言和类型 switch，需要让自定义的错误变为 public。这导致和调用者产生强耦合，从而导致API变得脆弱。</p>
<p>结论：尽量避免使用 error types，虽然错误类型比 sentinel errors 更好，因为它们可以捕获关于出错的更多上下文，但是 error types 有着和 error values 许多相同的问题。因此，我的建议是避免使用 error types，或者至少避免将它们作为公共 API 的一部分。</p>
<h2 id="Opaque-errors"><a href="#Opaque-errors" class="headerlink" title="Opaque errors"></a>Opaque errors</h2><p>在我看来，这是最灵活的错误处理策略，因为它解除了代码与它的调用者之间的耦合，这种风格称为 opaque errors 处理。因为虽然你知道发生了错误，但你无法看到错误的内部，作为调用者，你只知道操作的结果到底是成功了还是失败了。这就是 opaque errors 的全部内容，只需返回错误而无需假设其内容。 如果你采用此策略，那么错误处理作为调试辅助工具将变得更加有用。</p>
<p>考虑以下代码：</p>
<pre><code class="go">import “github.com/quux/bar”

func fn() error &#123;
        x, err := bar.Foo()
        if err != nil &#123;
                return err
        &#125;
        // use x
&#125;</code></pre>
<p>例如，<code>Foo</code> 声明的合约不保证在错误的情况下它将返回什么。 <code>Foo</code> 的作者现在可以自由注释带有附加上下文的传递给它的错误，而不会破坏与调用方的约定。</p>
<h3 id="注释错误"><a href="#注释错误" class="headerlink" title="注释错误"></a>注释错误</h3><p>也就是给错误添加上下文信息。考虑以下代码片段：</p>
<pre><code class="go">
func main() &#123;
    err := func1()
    if err != nil &#123;
        log.Print(err)
        return
    &#125;
&#125;

func func1() error &#123;
    ...
    return func2()
    ...
&#125;

func func2() error &#123;
    ...
    return func3()
    ...
&#125;

func func3() error &#123;
    ...
    err := ...
    if err != nil &#123;
        return err
    &#125;
    ...

    return nil
&#125;</code></pre>
<p>假设 <code>main</code> 执行后日志打印<code>No such file or directory</code>，但是我们没有文件和生成错误的行的信息。，没有导致错误的调用堆栈的堆栈跟踪。 我们将被迫花费很长的时间来调试、跟踪代码，以发现哪个代码路径触发了这个错误。</p>
<p>我们可以对代码做一些改进，给各个函数返回的错误添加上下文信息：</p>
<pre><code class="go">func main() &#123;
    err := func1()
    if err != nil &#123;
        log.Print(err)
        return
    &#125;
&#125;

func func1() error &#123;
    err := ...
    if err != nil &#123;
        return errors.Newf(&quot;func1 failed: %v&quot;, err)
    &#125;
    return func2()
&#125;

func func2() error &#123;
    err := ...
    if err != nil &#123;
        return errors.Newf(&quot;func2 failed: %v&quot;, err)
    &#125;
    return func3()
&#125;

func func3() error &#123;
    err := ...
    if err != nil &#123;
        return errors.Newf(&quot;func3 failed: %v&quot;, err)
    &#125;
    return nil
&#125;</code></pre>
<p>这样，当 <code>main</code> 函数打印错误时，我们就能知道到底是哪个地方出了错，就能快速定位到问题的所在。</p>
<p>但是，正如我们前面所看到的，这种模式与使用 Sentinel errors 或 Error types 不兼容，因为将错误转换为字符串，将其与另一个字符串合并，然后使用fmt将其转换成一个新的错误， 破坏了原始错误中的任何上下文。</p>
<p>现在我们陷入了一个非常矛盾的处境：我们既希望能避免使用 sentinel errors 和 error types 带来的包与包之间的强耦合性，也希望能拥有 opaque errors 的灵活性，比如给错误添加上下文信息，但又不想破坏了原始错误中的任何上下文，怎么办呢？wrap errors 来帮忙！</p>
<h3 id="Wrap-errors"><a href="#Wrap-errors" class="headerlink" title="Wrap errors"></a>Wrap errors</h3><p>顾名思义，Wrap errors 的意思就是给错误做包装。Go 社区的常见的解决方案是使用 <a target="_blank" rel="noopener" href="http://github.com/pkg/errors">pkg/errors</a> ，这个库有两个主要函数：</p>
<pre><code class="go">// Wrap annotates cause with a message.
func Wrap(cause error, message string) error</code></pre>
<p>第一个函数是 <code>Wrap</code>，给它一个错误和一条消息，它将产生一个新的错误。</p>
<pre><code class="go">// Cause unwraps an annotated error.
func Cause(err error) error</code></pre>
<p>第二个函数是 <code>Cause</code>，给他一个可能包装有其它错误的错误，它将其解包以拿到里层原始的错误。</p>
<p>使用这两个函数，我们现在可以给任何错误添加标记，并在需要检查时拿到原始的根因错误。 考虑这个将文件内容读入内存的函数的示例。</p>
<pre><code class="go">func ReadFile(path string) ([]byte, error) &#123;
        f, err := os.Open(path)
        if err != nil &#123;
                return nil, errors.Wrap(err, &quot;open failed&quot;)
        &#125; 
        defer f.Close()

        buf, err := ioutil.ReadAll(f)
        if err != nil &#123;
                return nil, errors.Wrap(err, &quot;read failed&quot;)
        &#125;
        return buf, nil
&#125;</code></pre>
<p>我们将使用此函数编写一个函数来读取配置文件，然后从 <code>main</code> 调用该函数。</p>
<pre><code class="go">func ReadConfig() ([]byte, error) &#123;
        home := os.Getenv(&quot;HOME&quot;)
        config, err := ReadFile(filepath.Join(home, &quot;.settings.xml&quot;))
        return config, errors.Wrap(err, &quot;could not read config&quot;)
&#125;

func main() &#123;
        _, err := ReadConfig()
        if err != nil &#123;
                fmt.Println(err)
                os.Exit(1)
        &#125;
&#125;</code></pre>
<p>如果 <code>ReadConfig</code> 返回了错误，由于使用了<code>errors.Wrap</code> ，我们的得到的错误的上下文信息很完备:</p>
<pre><code class="go">could not read config: open failed: open /Users/dfc/.settings.xml: no such file or directory</code></pre>
<p>因为 <code>errors.Wrap</code> 会产生一个错误的堆栈，所以我们可以检查该堆栈以获取其他调试信息。 </p>
<p>我们引入了包装错误以产生堆栈的概念，接下来我们需要讨论相反的情况，将它们展开。 这是错误的原因。原因函数。</p>
<pre><code class="go">// IsTemporary returns true if err is temporary.
func IsTemporary(err error) bool &#123;
        te, ok := errors.Cause(err).(temporary)
        return ok &amp;&amp; te.Temporary()
&#125;</code></pre>
<p>在操作中，每当需要检查与特定值或类型匹配的错误时，都应首先使用 <code>errors.Cause</code> 函数恢复原始错误。</p>
<p><a target="_blank" rel="noopener" href="http://github.com/pkg/errors">pkg/errors</a> 解决了我们的难题，那么它的工作原理是什么？很简单：</p>
<pre><code class="go">// Wrap returns an error annotating err with a stack trace
// at the point Wrap is called, and the supplied message.
// If err is nil, Wrap returns nil.
func Wrap(err error, message string) error &#123;
    if err == nil &#123;
        return nil
    &#125;
    err = &amp;withMessage&#123;
        cause: err,
        msg:   message,
    &#125;
    return &amp;withStack&#123;
        err,
        callers(),
    &#125;
&#125;</code></pre>
<p>它的工作原理从它的名字就可以看出来：把原始错误封装在新错误的 <code>cause</code> 字段，<code>withMessage</code> 和 <code>withStack</code> 都实现了此接口：</p>
<pre><code class="go">type causer interface &#123;
        Cause() error
    &#125;</code></pre>
<p>再来看 <code>Cause</code> 函数：</p>
<pre><code class="go">// Cause returns the underlying cause of the error, if possible.
// An error value has a cause if it implements the following
// interface:
//
//     type causer interface &#123;
//            Cause() error
//     &#125;
//
// If the error does not implement Cause, the original error will
// be returned. If the error is nil, nil will be returned without further
// investigation.
func Cause(err error) error &#123;
    type causer interface &#123;
        Cause() error
    &#125;

    for err != nil &#123;
        cause, ok := err.(causer)
        if !ok &#123;
            break
        &#125;
        err = cause.Cause()
    &#125;
    return err
&#125;</code></pre>
<p><code>Cause</code> 获取原始的错误，首先就是看经过保证的错误有没有实现 <code>causer</code> 接口，有的话调用 <code>Cause()</code> 返回就拿到了原始的错误。</p>
<p>在 wrap errors 中使用 sentinel errors</p>
<p>在使用 wrap errors 时，在少数情况我们还需要用到 sentinel errors，这时我们可以使用 <code>errors.Is(err, target error) bool</code>，它可以判断一个错误的链里是否有任何错误是跟 <code>target</code> 是匹配的。</p>
<p>在 wrap errors 中使用 error types</p>
<p>在少数情况我们还需要用到 error types，这时我们可以使用 <code>errors.As(err error, target interface&#123;&#125;) bool</code>，它可以判断一个错误的链里的第一个跟 <code>target</code> 同类型的错误，如果找到了，将错误值赋值给 <code>target</code> 并返回 <code>true</code>。</p>
<h3 id="Wrap-errors-最佳实践"><a href="#Wrap-errors-最佳实践" class="headerlink" title="Wrap errors 最佳实践"></a>Wrap errors 最佳实践</h3><p>什么样的 wrap errors 错误处理实践才是好的？我们肯定会回答说能帮助我们定位到错误现场的就是好的，考虑以下代码：</p>
<pre><code class="go">func main() &#123;
    err := func1()
    if err != nil &#123;
        log.Print(err)
        return
    &#125;
&#125;

func func1() error &#123;
    err := ...
    if err != nil &#123;
        return err
    &#125;
    return func2()
&#125;

func func2() error &#123;
    err := ...
    if err != nil &#123;
        return err
    &#125;
    return func3()
&#125;

func func3() error &#123;
    err := ...
    if err != nil &#123;
        return err
    &#125;
    return nil
&#125;</code></pre>
<p>假设 <code>main</code> 函数执行后打印了错误：<code>No such file or directory</code>，很明显这个错误处理方式无法帮助我们定位到错误现场。而要找到这种代码里的错误的代价也太大了点，对于一个代码量多、功能复杂的应用，我们可能要经历：修改代码 → 提交MR → 等待代码得到 review → 部署到测试环境。</p>
<p>于是，我们学会了将代码改进成：</p>
<pre><code class="go">func main() &#123;
    err := func1()
    if err != nil &#123;
        log.Print(err)
        return
    &#125;
&#125;

func func1() error &#123;
    err := ... // func1 产生的错误
    if err != nil &#123;
        return fmt.Errorf(&quot;func1 error: %v&quot;, err)
    &#125;
    return func2()
&#125;

func func2() error &#123;
    err := ... // func2 产生的错误
    if err != nil &#123;
        return fmt.Errorf(&quot;func2 error: %v&quot;, err)
    &#125;
    return func3()
&#125;

func func3() error &#123;
    err := ...
    if err != nil &#123;
        return fmt.Errorf(&quot;func3 error: %v&quot;, err)
    &#125;
    return nil
&#125;</code></pre>
<p>通过这种方式，当 <code>main</code> 打印了错误时，我们便能一眼定位到错误现场。</p>
<p>上边我们是通过给错误添加注释/上下文信息，让错误信息成为一个错误的 identifition。把控上下文信息的多少很关键，既不能多了，也不能少了，只能是刚刚好。如何做到这一点呢？从整个调用链的角度去考虑，而不是只看到一个点 ：</p>
<pre><code class="go">func func3() error &#123;
    err := ...
    if err != nil &#123;
        return fmt.Errorf(&quot;func3 error: %v&quot;, err)
    &#125;
    return nil
&#125;</code></pre>
<p><code>func3</code> 的作者已经将这个函数返回的错误都加上下文了，因此 <code>func3</code> 的调用者也就没必要再给错误添加上下文了。</p>
<p>总结一下技巧：</p>
<ol>
<li><p>在团队的项目中，业务代码使用 <code>errors.New</code> 或者 <code>errors.Newf</code>生成一个新的错误并返回：</p>
<pre><code class="go">func parseArgs(args []string) error &#123;
    if len(args) &lt; 3 &#123;
        return errors.Newf(&quot;args length is %d, expect %d&quot;, len(args), 3)
    &#125;
&#125;</code></pre>
</li>
<li><p>在团队的项目中，调用同项目内的函数遇到错误，通常直接返回错误。因为按照上面第 1 点，你得到的错误已经是一个已经加了上下文信息的错误，所以无需再重复添加上下文信息：</p>
<pre><code class="go">err := parseArgs()
if err != nil &#123;
    return err
&#125;</code></pre>
</li>
<li><p>在业务代码中， 与标准库或者第三方的库（GitHub 上的 ）进行协作的时候，考虑使用 <code>errors.Wrap</code> 或者 <code>errors.Wrapf</code>包装错误以保存堆栈信息：</p>
<pre><code class="go">f, err := os.Open(path)
if err != nil &#123;
    return errors.Wrapf(err, &quot;open file %q&quot;, path)
&#125;</code></pre>
</li>
<li><p>调用链的中间节点，直接返回错误，而不是在每个错误产生的地方导出打印日志，最终在调用链的开始处使用 <code>%+v</code> 把堆栈信息打印出来：</p>
<pre><code class="go">func main() &#123;
    err := app.Run()
    if err != nil &#123;
        log.Print(err)
        os.Exit(1)
    &#125;
&#125;</code></pre>
</li>
<li><p>实在需要使用 sentinel error 或者 error types 的地方，使用 <code>errors.Cause</code> 获取根因错误，再和 sentinel error 做等值比较或者做 type assertion；</p>
</li>
<li><p>非业务代码、基础公共库等代码，直接返回原始错误即可，让调用方负责给错误加上上下文信息。</p>
</li>
</ol>
<h3 id="断言错误的行为，而不是类型"><a href="#断言错误的行为，而不是类型" class="headerlink" title="断言错误的行为，而不是类型"></a>断言错误的行为，而不是类型</h3><p>在少数情况下，opaque error 这种非此即彼的错误处理方法是不够的。有一些场景我们是需要详细的 error 信息的、底层的错误，</p>
<p>例如，与进程外的世界进行交互，需要调用方调查错误的性质，以确定是否需要重试。在这种情况下，我们检查错误实现了特定的行为，而不是断言错误是特定的类型或值。考虑这个例子:</p>
<pre><code class="go">package net

// An Error represents a network error.
type Error interface &#123;
    error
    Timeout() bool   // Is the error a timeout?
    Temporary() bool // Is the error temporary?
&#125;</code></pre>
<p>这是 net 的 Error 接口，</p>
<pre><code class="go">if nerr, ok := err.(net.Error); ok &amp;&amp; nerr.Temporary() &#123;
    time.Sleep(1e9)
    continue
&#125;
if err != nil &#123;
    log.Fatal(err)
&#125;</code></pre>
<p>这里我们判断 err 是否是 <code>net.Error</code>，如果是的话，是不是 temporary 错误，</p>
<pre><code class="go">// main.go

type temporary interface &#123;
    Temporary() bool
&#125;

func IsTemporary(err error) bool &#123;
    te, ok := err.(temporary)
    return ok &amp;&amp; te.Temporary()
&#125;

func main() &#123;
    err := ...
    if IsTemporary(err) &#123; 
        // 假设在这里我们要判断 err 是否是 net.Error 的 Temporary
        // 通过在上边定义了一个 temporary 接口和 IsTemporary 方法
        // 我们无需导入 net 包即可判断 err 是否是 Temporary 这个行为

    &#125;
&#125;</code></pre>
<p>这里我们在本地声明了一个 <code>temporary</code> 接口，用于断言 err 是否具有 <code>temporary</code> 的这个行为。这里的关键是，可以在不导入定义错误的程序包或实际上不了解有关错误底层类型的任何信息的情况下实现此逻辑，我们只是对其行为感兴趣。</p>
<h3 id="error-处理库的选择"><a href="#error-处理库的选择" class="headerlink" title="error 处理库的选择"></a>error 处理库的选择</h3><p><a target="_blank" rel="noopener" href="https://github.com/pkg/errors">pkg/errors</a> 在 Go 社区被广泛使用，借助这个库我们就能方便地应用上述的错误处理实践方式。另外社区也有一些基于 pkg/errors 不断扩展的库，比如 <a target="_blank" rel="noopener" href="https://github.com/cockroachdb/errors">cockroachdb/errors</a>，提供了非常多的<a target="_blank" rel="noopener" href="https://github.com/cockroachdb/errors">特性</a>，非常值得一试。</p>
<h1 id="Error-处理技巧"><a href="#Error-处理技巧" class="headerlink" title="Error 处理技巧"></a>Error 处理技巧</h1><h2 id="Fail-fast-尽早处理错误"><a href="#Fail-fast-尽早处理错误" class="headerlink" title="Fail-fast: 尽早处理错误"></a>Fail-fast: 尽早处理错误</h2><p>Go 代码里 <code>if err != nil &#123;&#125;</code> 会非常多，所以我们要在每次遇到错误时就立马处理错误并终止执行流程，避免有过多的嵌套代码块。示例：</p>
<pre><code class="go">// do this
f, err := func1()
if err != nil &#123;
    // 处理错误
&#125;

// 没有错误，继续执行流程
err = func1()
if err != nil &#123;
    // 处理错误
&#125;

// 没有错误，继续执行流程
err = func3()
if err != nil &#123;
    // 处理错误
&#125;

// 没有错误，继续执行流程

...

return nil

// ====== 分割线 ======

// don&#39;t do this
f, err := os.func1()
if err == nil &#123;
    // 没有错误，继续执行流程
    err = func2()
    if err == nil &#123;
        // 没有错误，继续执行流程
        err = func3()
        if err == nil &#123;
            // 没有错误，继续执行流程
            return nil
        &#125;
        // 有错误，处理错误
    &#125;
        // 有错误，处理错误
&#125;
// 有错误，处理错误</code></pre>
<p>这两种写法中第 1 种更合理，且可读性更好；第 2 种写法是糟糕的，代码有很多缩进块，可读性很差。人脑天生不适合去理解这种层层嵌套的东西（想想递归函数，你能往脑袋里压进所有的递归调用吗😂）。</p>
<h2 id="通过减少错误出现的次数的方式去减少错误处理的次数"><a href="#通过减少错误出现的次数的方式去减少错误处理的次数" class="headerlink" title="通过减少错误出现的次数的方式去减少错误处理的次数"></a>通过减少错误出现的次数的方式去减少错误处理的次数</h2><p>要这样子：</p>
<pre><code class="go">func AuthenticateRequest(r *Request) error &#123;
    return authenticate(r.User)
&#125;</code></pre>
<p>不要这样子：</p>
<pre><code class="go">func AuthenticateRequest(r *Request) error &#123;
    err := authenticate(r.User)
    if err != nil &#123;
        return err
    &#125;
    return nil
&#125;</code></pre>
<p>来看一个 Rob Pike 的例子：</p>
<pre><code class="go">_, err = fd.Write(p0[a:b])
if err != nil &#123;
    return err
&#125;
_, err = fd.Write(p1[c:d])
if err != nil &#123;
    return err
&#125;
_, err = fd.Write(p2[e:f])
if err != nil &#123;
    return err
&#125;
// and so on</code></pre>
<p>这段代码有 3 个错误是否为 nil 的检查，这些重复、繁琐的代码让代码失去了优雅。应用同样的原理，这段代码可以优化为：</p>
<pre><code class="go">type errWriter struct &#123;
    w   io.Writer
    err error
&#125;

func (ew *errWriter) write(buf []byte) &#123;
    if ew.err != nil &#123;
        return
    &#125;
    _, ew.err = ew.w.Write(buf)
&#125;

ew := &amp;errWriter&#123;w: fd&#125;
ew.write(p0[a:b])
ew.write(p1[c:d])
ew.write(p2[e:f])
// and so on
if ew.err != nil &#123;
    return ew.err
&#125;</code></pre>
<p>最后得到的代码更加简洁、优雅。</p>
<h2 id="Only-handle-errors-once"><a href="#Only-handle-errors-once" class="headerlink" title="Only handle errors once"></a>Only handle errors once</h2><p>Dave Cheney 在中提到，我们只应该处理错误一次。处理错误意味着检查错误值并做出决定。这句话的意思每一次检查错误，我们只应该做出一个选择。</p>
<p>对于一个错误，如果你做出少于一次的选择（没有接收函数返回的 error，或者接收了但不处理），你就是在忽略错误。就像我们在这里看到的，<code>w.Write</code> 返回的错误没有被接收：</p>
<pre><code class="go">func Write(w io.Writer, buf []byte) &#123;
        w.Write(buf)
&#125;</code></pre>
<p>对于一个错误，如果你做出多于一次的选择也是有问题的：</p>
<pre><code class="go">func Write(w io.Writer, buf []byte) error &#123;
        _, err := w.Write(buf)
        if err != nil &#123;
                // annotated error goes to log file
                log.Println(&quot;unable to write:&quot;, err)

                // unannotated error returned to caller
                return err
        &#125;
        return nil
&#125;</code></pre>
<p>在这个例子中，如果 <code>w.Write</code> 返回了一个错误，那么代码会打印一条日志，接下来这个错误被返回给 <code>Write</code> 的调用者，而 <code>Write</code> 的调用者也有可能会做同样的操作：打印日志，然后继续向上透传。而调用者的调用者也做同样的事情，依次类推，直到达到调用链的开始。</p>
<p>这样我们得到了多余的、重复的日志打印，这是很糟糕的，无益于我们跟踪错误。而且在调用链的开始处，我们得到的是没有任何上下文的原始错误，导致我们无法判断错误是从调用链中的哪一个节点抛出的。<code>Wrap errors</code> 这个时候派上了用场：</p>
<pre><code class="go">func Write(w io.Write, buf []byte) error &#123;
        _, err := w.Write(buf)
        return errors.Wrap(err, &quot;write failed&quot;)
&#125;</code></pre>
<p>使用 errors package，给错误添加上下文信息，这样程序员和机器都是很好地检查错误。</p>
<p>参考：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.golang.org/errors-are-values">Errors are values</a></li>
<li><a target="_blank" rel="noopener" href="https://dave.cheney.net/2016/04/27/dont-just-check-errors-handle-them-gracefully">Don’t just check errors, handle them gracefully</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.golang.org/error-handling-and-go">Error handling and Go</a></li>
<li><a target="_blank" rel="noopener" href="https://u.geekbang.org/subject/go">Go进阶训练营</a></li>
</ul>
</div></div></body><script src="/js/highlight.min.js"></script><script src="/js/main.js"></script><script src="/js/bootstrap/bootstrap.min.js"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', '');</script></html>