<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"danceinstyle.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="如何正确而优雅地处理错误是每个 Go 程序员都要思考的一个问题。Go 处理错误的方式不同于主流语言，不像 Java 使用 try catch finally 语句去处理程序的异常&#x2F;错误，Go 中没有这样的错误处理语句。 在 Go 中，错误处理意味着检查错误值并做出决定，Go 错误处理的精髓是基于其以下语言特性：">
<meta property="og:type" content="article">
<meta property="og:title" content="Go Errors Handling">
<meta property="og:url" content="https://danceinstyle.github.io/2021/05/20/go-errors-handling/index.html">
<meta property="og:site_name" content="破障者">
<meta property="og:description" content="如何正确而优雅地处理错误是每个 Go 程序员都要思考的一个问题。Go 处理错误的方式不同于主流语言，不像 Java 使用 try catch finally 语句去处理程序的异常&#x2F;错误，Go 中没有这样的错误处理语句。 在 Go 中，错误处理意味着检查错误值并做出决定，Go 错误处理的精髓是基于其以下语言特性：">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2021-05-20T12:20:57.000Z">
<meta property="article:modified_time" content="2021-05-23T05:45:21.612Z">
<meta property="article:author" content="破障者">
<meta property="article:tag" content="go">
<meta property="article:tag" content="best-practice">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://danceinstyle.github.io/2021/05/20/go-errors-handling/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Go Errors Handling | 破障者</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">破障者</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">人生在于不断破除障碍</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://danceinstyle.github.io/2021/05/20/go-errors-handling/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/hotballoon.jpg">
      <meta itemprop="name" content="破障者">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="破障者">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Go Errors Handling
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/go/" itemprop="url" rel="index"><span itemprop="name">go</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>如何正确而优雅地处理错误是每个 Go 程序员都要思考的一个问题。Go 处理错误的方式不同于主流语言，不像 Java 使用 <code>try catch finally</code> 语句去处理程序的异常/错误，Go 中没有这样的错误处理语句。</p>
<p>在 Go 中，错误处理意味着检查错误值并做出决定，Go 错误处理的精髓是基于其以下语言特性：</p>
<a id="more"></a>

<ol>
<li>errors are values。在 Go 中错误就是值，就像 <code>&quot;hello world&quot;</code> 之于 <code>string</code>，我们使用变量去承载错误。Go 用户必须检查函数返回的错误的值，结合 <code>if else</code> 或者 <code>switch case</code> 语句去做流程控制（终止程序执行流程、继续执行流程）；</li>
<li>函数可以有多个返回值，如果函数要返回错误，那么最佳实践是把错误放在多个返回值中的最后一个，形如这个函数签名：<code>func func1() (int, int, error)</code>。这一点非常显而易见，以至于很多人常常忽略掉这个特性在错误处理中的存在。</li>
</ol>
<p>这也是其它语言的用户使用 Go 语言时经常谈到的（好的、坏的），有人会认为这种处理方式导致代码里有太多繁琐的、重复的 <code>if err ≠ nil &#123;&#125;</code>。关于如何处理错误的讨论有很多，这个话题也成为了很多演讲者的演讲主题。本文由浅入深，总结一下错误处理的经验。</p>
<h1 id="Error-的处理策略"><a href="#Error-的处理策略" class="headerlink" title="Error 的处理策略"></a>Error 的处理策略</h1><p>Go 代码中常见的错误处理策略有三种：</p>
<ol>
<li>Sentinel errors</li>
<li>Error types</li>
<li>Opaque errors</li>
</ol>
<p>接下来我将一一介绍它们，描述各自的优缺点，最后总结出一个我愿意在项目中使用的错误处理实践。</p>
<h2 id="Sentinel-errors"><a href="#Sentinel-errors" class="headerlink" title="Sentinel errors"></a>Sentinel errors</h2><p>预定义的值等于特定值的错误，称为 sentinel errors。它的工作原理是当我们得到一个错误值，拿它跟目标 sentinel error 做等值比较：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> a</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义 sentinal error，一般是导出的</span></span><br><span class="line"><span class="keyword">var</span> SomeError = errors.New(<span class="string">&quot;something bad happened&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// someFunc 是一个任意函数，它可能会返回 SomeError</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">someFunc</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> expect, got <span class="keyword">int</span></span><br><span class="line">	<span class="comment">// 经过一系列处理...</span></span><br><span class="line">	<span class="keyword">if</span> a != b &#123;</span><br><span class="line">		<span class="keyword">return</span> SomeError</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ====== 分割线 ======</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> b</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;a&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// someFunc 的调用方关心得到的 err 是不是 SomeError，因此需要做一个等值比较</span></span><br><span class="line">err := someFunc()</span><br><span class="line"><span class="keyword">if</span> err == SomeError &#123;</span><br><span class="line">	<span class="comment">// 如果是 SomeError，那么做一些处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Sentinel errors 是最不灵活的错误处理策略，因为调用方必须使用 <code>==</code> 将结果与预先声明的值进行比较。当你想要提供更多的上下文时，这就出现问题，因为返回一个不同的错误值将破坏现有的相等性检查。甚至是一些有意义的 <code>fmt.Errorf()</code> 携带一些上下文，也会破坏调用者的 <code>==</code>，调用者将被迫查看 <code>error.Error()</code> 方法的输出，以查看它是否跟特定的字符串匹配。但我们不应该依赖检测 <code>error.Error()</code> 的输出，<code>error.Error()</code>方法存在于 <code>error</code> 接口主要用户方便程序员使用，而不是程序。这个输出的字符串只是用来方便用户记录日志、输出到 stdout 等。</p>
<p>Sentinel errors 的弊端：</p>
<ol>
<li>Sentinel errors 成为了你 API 的公共部分。如果你的公共函数或方法返回一个特定值的错误，那么该值必须是公共的，当然要有文档记录，增加了 API 的表面积。如果 API 定义了一个返回特定错误的 <code>interface</code>，则该接口的所有实现都将被限制为返回该错误，即使它们可以提供更具描述性的错误。比如 <code>io.Reader</code>，像 <code>io.Copy</code> 这类函数需要 <code>reader</code> 的实现者比如返回 <code>io.EOF</code> 来告诉调用者没有更多数据了，但这又不是错误。</li>
<li>Sentinel errors 在两个包之间创建了依赖。Sentinel errors 最糟糕的问题是它们在两个包之间创建了源代码依赖关系。例如，检查错误是否等于 <code>io.EOF</code> ，你的代码必须导入 <code>io</code> 包。这个特定的例子听起来并不那么糟糕，因为它非常常见，但是想象一下，当项目中的许多包导出错误值时，包与包之间存在耦合，项目中的其他包必须导入这些错误值才能检查特定的错误条件。</li>
</ol>
<p>结论：尽可能避免 sentinel errors。我的建议是避免在编写的代码中使用 sentinel errors。在标准库中有一些使用它们的情况，但这不是一个我们应该模仿的模式。</p>
<h2 id="Error-types"><a href="#Error-types" class="headerlink" title="Error types"></a>Error types</h2><p>Error types 是实现了 error 接口的自定义类型，例如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyError <span class="keyword">struct</span> &#123;</span><br><span class="line">	Msg  <span class="keyword">string</span></span><br><span class="line">	File <span class="keyword">string</span></span><br><span class="line">	Line <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *MyError)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;%s:%d:%s&quot;</span>, e.File, e.Line, e.Msg)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;MyError&#123;<span class="string">&quot;Something happened&quot;</span>, <span class="string">&quot;server.go&quot;</span>, <span class="number">42</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为 <code>MyError</code> 是一个 type，调用者可以使用断言转换成这个类型，来获取更多的上下文信息：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	err := test()</span><br><span class="line">	<span class="keyword">switch</span> err := err.(<span class="keyword">type</span>) &#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="literal">nil</span>:</span><br><span class="line">			<span class="comment">// call succeeded, nothing to do</span></span><br><span class="line">		<span class="keyword">case</span> *MyError:</span><br><span class="line">			fmt.Println(<span class="string">&quot;error occurred on line: &quot;</span>, err.line)</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="comment">// unknown error</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Error types 解决了 sentinel errors 的一个问题，带来了以下改进：</p>
<ol>
<li>错误的上下文信息更丰富。而 sentinel error 的值是固定的，在程序启动的时候已经初始化，基本没有上下文信息，只是一个“哨兵“；</li>
</ol>
<p>一个不错的例子是 <code>os.PathError</code>，它提供了底层执行了什么操作、哪个路径出了问题：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PathError records an error and the operation and file path that caused it.</span></span><br><span class="line"><span class="keyword">type</span> PathError <span class="keyword">struct</span> &#123;</span><br><span class="line">	Op   <span class="keyword">string</span></span><br><span class="line">	Path <span class="keyword">string</span></span><br><span class="line">	Err  error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *PathError)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span> &#123; <span class="keyword">return</span> e.Op + <span class="string">&quot; &quot;</span> + e.Path + <span class="string">&quot;: &quot;</span> + e.Err.Error() &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *PathError)</span> <span class="title">Unwrap</span><span class="params">()</span> <span class="title">error</span></span> &#123; <span class="keyword">return</span> e.Err &#125;</span><br></pre></td></tr></table></figure>

<p>虽然 error types 为错误提供详细的上下文信息，当仍然存在问题：调用者要使用类型断言和类型 switch，就要让自定义的错误变为 public。这导致和调用者产生强耦合，从而导致API变得脆弱。</p>
<p>结论：尽量避免使用 error types，虽然错误类型比 sentinel errors 更好，因为它们可以捕获关于出错的更多上下文，但是 error types 有着和 error values 许多相同的问题。因此，我的建议是避免使用 error types，或者至少避免将它们作为公共 API 的一部分。</p>
<h2 id="Opaque-errors"><a href="#Opaque-errors" class="headerlink" title="Opaque errors"></a>Opaque errors</h2><p>在我看来，这是最灵活的错误处理策略，因为它解除了代码与它的调用者之间的耦合，这种风格称为 opaque errors 处理。因为虽然你知道发生了错误，但你无法看到错误的内部，作为调用者，你只知道操作的结果到底是成功了还是失败了。这就是 opaque errors 的全部内容，只需返回错误而无需假设其内容。 如果你采用此策略，那么错误处理作为调试辅助工具将变得更加有用。</p>
<p>考虑以下代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> “github.com/quux/bar”</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fn</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">        x, err := bar.Foo()</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> err</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// use x</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例如，<code>Foo</code> 声明的合约不保证在错误的情况下它将返回什么。 <code>Foo</code> 的作者现在可以自由注释带有附加上下文的传递给它的错误，而不会破坏与调用方的约定。</p>
<h3 id="注释错误"><a href="#注释错误" class="headerlink" title="注释错误"></a>注释错误</h3><p>也就是给错误添加上下文信息。考虑以下代码片段：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	err := func1()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Print(err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">func1</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">return</span> func2()</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">func2</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">return</span> func3()</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">func3</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	...</span><br><span class="line">	err := ...</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设 <code>main</code> 执行后日志打印<code>No such file or directory</code>，但是我们没有文件和生成错误的行的信息。，没有导致错误的调用堆栈的堆栈跟踪。 我们将被迫花费很长的时间来调试、跟踪代码，以发现哪个代码路径触发了这个错误。</p>
<p>我们可以对代码做一些改进，给各个函数返回的错误添加上下文信息：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	err := func1()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Print(err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">func1</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	err := ...</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> errors.Newf(<span class="string">&quot;func1 failed: %v&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> func2()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">func2</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	err := ...</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> errors.Newf(<span class="string">&quot;func2 failed: %v&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> func3()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">func3</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	err := ...</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> errors.Newf(<span class="string">&quot;func3 failed: %v&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，当 <code>main</code> 函数打印错误时，我们就能知道到底是哪个地方出了错，就能快速定位到问题的所在。</p>
<p>但是，正如我们前面所看到的，这种模式与使用 Sentinel errors 或 Error types 不兼容，因为将错误转换为字符串，将其与另一个字符串合并，然后使用fmt将其转换成一个新的错误， 破坏了原始错误中的任何上下文。</p>
<p>现在我们陷入了一个非常矛盾的处境：我们既希望能避免使用 Sentinel errors 和 Error types 带来的包与包之间的强耦合性，也希望能拥有 Opaque errors 的灵活性，比如给错误添加上下文信息，但又不想破坏了原始错误中的任何上下文，怎么办呢？Wrap errors 来帮忙！</p>
<h3 id="Wrap-errors"><a href="#Wrap-errors" class="headerlink" title="Wrap errors"></a>Wrap errors</h3><p>顾名思义，Wrap errors 的意思就是给错误做包装。Go 社区的常见的解决方案是使用 <a target="_blank" rel="noopener" href="http://github.com/pkg/errors">pkg/errors</a> ，这个库有两个主要函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Wrap annotates cause with a message.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Wrap</span><span class="params">(cause error, message <span class="keyword">string</span>)</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure>

<p>第一个函数是 <code>Wrap</code>，给它一个错误和一条消息，它将产生一个新的错误。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Cause unwraps an annotated error.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Cause</span><span class="params">(err error)</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure>

<p>第二个函数是 <code>Cause</code>，给他一个可能包装有其它错误的错误，它将其解包以拿到里层原始的错误。</p>
<p>使用这两个函数，我们现在可以给任何错误添加标记，并在需要检查时拿到原始的根因错误。 考虑这个将文件内容读入内存的函数的示例。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReadFile</span><span class="params">(path <span class="keyword">string</span>)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span> &#123;</span><br><span class="line">        f, err := os.Open(path)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nil</span>, errors.Wrap(err, <span class="string">&quot;open failed&quot;</span>)</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">defer</span> f.Close()</span><br><span class="line"> </span><br><span class="line">        buf, err := ioutil.ReadAll(f)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nil</span>, errors.Wrap(err, <span class="string">&quot;read failed&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> buf, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们将使用此函数编写一个函数来读取配置文件，然后从 <code>main</code> 调用该函数。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReadConfig</span><span class="params">()</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span> &#123;</span><br><span class="line">        home := os.Getenv(<span class="string">&quot;HOME&quot;</span>)</span><br><span class="line">        config, err := ReadFile(filepath.Join(home, <span class="string">&quot;.settings.xml&quot;</span>))</span><br><span class="line">        <span class="keyword">return</span> config, errors.Wrap(err, <span class="string">&quot;could not read config&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        _, err := ReadConfig()</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                fmt.Println(err)</span><br><span class="line">                os.Exit(<span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果 <code>ReadConfig</code> 返回了错误，由于使用了<code>errors.Wrap</code> ，我们的得到的错误的上下文信息很完备:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">could not read config: open failed: open /Users/dfc/.settings.xml: no such file or directory</span><br></pre></td></tr></table></figure>

<p>因为 <code>errors.Wrap</code>会产生一个错误的堆栈，所以我们可以检查该堆栈以获取其他调试信息。 </p>
<p>我们引入了包装错误以产生堆栈的概念，接下来我们需要讨论相反的情况，将它们展开。 这是错误的原因。原因函数。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IsTemporary returns true if err is temporary.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IsTemporary</span><span class="params">(err error)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">        te, ok := errors.Cause(err).(temporary)</span><br><span class="line">        <span class="keyword">return</span> ok &amp;&amp; te.Temporary()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在操作中，每当需要检查与特定值或类型匹配的错误时，都应首先使用 <code>errors.Cause</code> 函数恢复原始错误。</p>
<p><a target="_blank" rel="noopener" href="http://github.com/pkg/errors">pkg/errors</a> 解决了我们的难题，那么它的工作原理是什么？很简单：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Wrap returns an error annotating err with a stack trace</span></span><br><span class="line"><span class="comment">// at the point Wrap is called, and the supplied message.</span></span><br><span class="line"><span class="comment">// If err is nil, Wrap returns nil.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Wrap</span><span class="params">(err error, message <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	err = &amp;withMessage&#123;</span><br><span class="line">		cause: err,</span><br><span class="line">		msg:   message,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> &amp;withStack&#123;</span><br><span class="line">		err,</span><br><span class="line">		callers(),</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它的工作原理从它的名字就可以看出来：把原始错误封装在新错误的 <code>cause</code> 字段，<code>withMessage</code> 和 <code>withStack</code> 都实现了此接口：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> causer <span class="keyword">interface</span> &#123;</span><br><span class="line">		Cause() error</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>再来看 <code>Cause</code> 函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Cause returns the underlying cause of the error, if possible.</span></span><br><span class="line"><span class="comment">// An error value has a cause if it implements the following</span></span><br><span class="line"><span class="comment">// interface:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//     type causer interface &#123;</span></span><br><span class="line"><span class="comment">//            Cause() error</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// If the error does not implement Cause, the original error will</span></span><br><span class="line"><span class="comment">// be returned. If the error is nil, nil will be returned without further</span></span><br><span class="line"><span class="comment">// investigation.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Cause</span><span class="params">(err error)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">type</span> causer <span class="keyword">interface</span> &#123;</span><br><span class="line">		Cause() error</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		cause, ok := err.(causer)</span><br><span class="line">		<span class="keyword">if</span> !ok &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		err = cause.Cause()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Cause</code> 获取原始的错误，首先就是看经过保证的错误有没有实现 <code>causer</code> 接口，有的话调用 <code>Cause()</code> 返回就拿到了原始的错误。</p>
<p>在 <strong>wrap errors 使用 sentinel errors</strong></p>
<p>在使用 wrap errors 时，在少数情况我们还需要用到 sentinel errors，这时我们可以使用 <code>errors.Is(err, target error) bool</code>，它可以判断一个错误的链里是否有任何错误是跟 <code>target</code> 是匹配的。</p>
<p>在 <strong>wrap errors 使用 error types</strong></p>
<p>在少数情况我们还需要用到 error types，这时我们可以使用 <code>errors.As(err error, target interface&#123;&#125;) bool</code>，它可以判断一个错误的链里的第一个跟 <code>target</code> 同类型的错误，如果找到了，将错误值赋值给 <code>target</code> 并返回 <code>true</code>。</p>
<h3 id="Wrap-errors-最佳实践"><a href="#Wrap-errors-最佳实践" class="headerlink" title="Wrap errors 最佳实践"></a>Wrap errors 最佳实践</h3><p>什么样的 wrap errors 错误处理实践才是好的？我们肯定会回答说能帮助我们定位到错误现场的就是好的，考虑以下代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	err := func1()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Print(err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">func1</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	err := ...</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> func2()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">func2</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	err := ...</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> func3()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">func3</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	err := ...</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设 <code>main</code> 函数执行后打印了错误：<code>No such file or directory</code>，很明显这个错误处理方式无法帮助我们定位到错误现场。而要找到这种代码里的错误的代价也太大了点，对于一个代码量多、功能复杂的应用，我们可能要经历：修改代码 → 提交MR → 等待代码得到 review → 部署到测试环境。</p>
<p>于是，我们学会了将代码改进成：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	err := func1()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Print(err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">func1</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	err := ... <span class="comment">// func1 产生的错误</span></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;func1 error: %v&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> func2()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">func2</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	err := ... <span class="comment">// func2 产生的错误</span></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;func2 error: %v&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> func3()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">func3</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	err := ...</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;func3 error: %v&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过这种方式，当 <code>main</code> 打印了错误时，我们便能一眼定位到错误现场。</p>
<p>上边我们是通过给错误添加注释/上下文信息，让错误信息成为一个错误的 identifition。把控上下文信息的多少很关键，既不能多了，也不能少了，只能是刚刚好。如何做到这一点呢？从整个调用链的角度去考虑，而不是只看到一个点 ：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">func3</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	err := ...</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;func3 error: %v&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>func3</code> 的作者已经将这个函数返回的错误都加上下文了，因此 <code>func3</code> 的调用者也就没必要再给错误添加上下文了。</p>
<p>总结一下技巧：</p>
<ol>
<li><p>在团队的项目中，业务代码使用 <code>errors.New</code> 或者 <code>errors.Newf</code>生成一个新的错误并返回：</p>
 <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">parseArgs</span><span class="params">(args []<span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(args) &lt; <span class="number">3</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> errors.Newf(<span class="string">&quot;args length is %d, expect %d&quot;</span>, <span class="built_in">len</span>(args), <span class="number">3</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在团队的项目中，调用同项目内的函数遇到错误，通常直接返回错误。因为按照上面第 1 点，你得到的错误已经是一个已经加了上下文信息的错误，所以无需再重复添加上下文信息：</p>
 <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">err := parseArgs()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在业务代码中， 与标准库或者第三方的库（GitHub 上的 ）进行协作的时候，考虑使用 <code>errors.Wrap</code> 或者 <code>errors.Wrapf</code>包装错误以保存堆栈信息：</p>
 <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">f, err := os.Open(path)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> errors.Wrapf(err, <span class="string">&quot;open file %q&quot;</span>, path)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>调用链的中间节点，直接返回错误，而不是在每个错误产生的地方导出打印日志，最终在调用链的开始处使用 <code>%+v</code> 把堆栈信息打印出来：</p>
 <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	err := app.Run()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Print(err)</span><br><span class="line">		os.Exit(<span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>实在需要使用 sentinel error 或者 error types 的地方，使用 <code>errors.Cause</code> 获取根因错误，再和 sentinel error 做等值比较或者做 type assertion；</p>
</li>
<li><p>非业务代码、基础公共库等代码，直接返回原始错误即可，让调用方负责给错误加上上下文信息。</p>
</li>
</ol>
<h3 id="断言错误的行为，而不是类型"><a href="#断言错误的行为，而不是类型" class="headerlink" title="断言错误的行为，而不是类型"></a>断言错误的行为，而不是类型</h3><p>在少数情况下，opaque error 这种非此即彼的错误处理方法是不够的。有一些场景我们是需要详细的 error 信息的、底层的错误，</p>
<p>例如，与进程外的世界进行交互，需要调用方调查错误的性质，以确定是否需要重试。在这种情况下，我们检查错误实现了特定的行为，而不是断言错误是特定的类型或值。考虑这个例子:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> net</span><br><span class="line"></span><br><span class="line"><span class="comment">// An Error represents a network error.</span></span><br><span class="line"><span class="keyword">type</span> Error <span class="keyword">interface</span> &#123;</span><br><span class="line">	error</span><br><span class="line">	Timeout() <span class="keyword">bool</span>   <span class="comment">// Is the error a timeout?</span></span><br><span class="line">	Temporary() <span class="keyword">bool</span> <span class="comment">// Is the error temporary?</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是 net 的 Error 接口，</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> nerr, ok := err.(net.Error); ok &amp;&amp; nerr.Temporary() &#123;</span><br><span class="line">	time.Sleep(<span class="number">1e9</span>)</span><br><span class="line">	<span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">	log.Fatal(err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们判断 err 是否是 <code>net.Error</code>，如果是的话，是不是 temporary 错误，</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> temporary <span class="keyword">interface</span> &#123;</span><br><span class="line">	Temporary() <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IsTemporary</span><span class="params">(err error)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	te, ok := err.(temporary)</span><br><span class="line">	<span class="keyword">return</span> ok &amp;&amp; te.Temporary()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	err := ...</span><br><span class="line">	<span class="keyword">if</span> IsTemporary(err) &#123; </span><br><span class="line">		<span class="comment">// 假设在这里我们要判断 err 是否是 net.Error 的 Temporary</span></span><br><span class="line">		<span class="comment">// 通过在上边定义了一个 temporary 接口和 IsTemporary 方法</span></span><br><span class="line">		<span class="comment">// 我们无需导入 net 包即可判断 err 是否是 Temporary 这个行为</span></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们在本地声明了一个 <code>temporary</code> 接口，用于断言 err 是否具有 <code>temporary</code> 的这个行为。这里的关键是，可以在不导入定义错误的程序包或实际上不了解有关错误底层类型的任何信息的情况下实现此逻辑，我们只是对其行为感兴趣。</p>
<h3 id="error-处理库的选择"><a href="#error-处理库的选择" class="headerlink" title="error 处理库的选择"></a>error 处理库的选择</h3><p><a target="_blank" rel="noopener" href="https://github.com/pkg/errors">pkg/errors</a> 在 Go 社区被广泛使用，借助这个库我们就能方便地应用上述的错误处理实践方式。另外社区也有一些基于 pkg/errors  不断扩展的库，比如 <a target="_blank" rel="noopener" href="https://github.com/cockroachdb/errors">cockroachdb/errors</a>，提供了非常多的<a target="_blank" rel="noopener" href="https://github.com/cockroachdb/errors">特性</a>，非常值得一试。</p>
<h1 id="Error-处理技巧"><a href="#Error-处理技巧" class="headerlink" title="Error 处理技巧"></a>Error 处理技巧</h1><h2 id="Fail-fast-尽早处理错误"><a href="#Fail-fast-尽早处理错误" class="headerlink" title="Fail-fast: 尽早处理错误"></a>Fail-fast: 尽早处理错误</h2><p>Go 代码里 <code>if err != nil &#123;&#125;</code> 会非常多，所以我们要在每次遇到错误时就立马处理错误并终止执行流程，避免有过多的嵌套代码块。示例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// do this</span></span><br><span class="line">f, err := func1()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">	<span class="comment">// 处理错误</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 没有错误，继续执行流程</span></span><br><span class="line">err = func1()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">	<span class="comment">// 处理错误</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 没有错误，继续执行流程</span></span><br><span class="line">err = func3()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">	<span class="comment">// 处理错误</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 没有错误，继续执行流程</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====== 分割线 ======</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// don&#x27;t do this</span></span><br><span class="line">f, err := os.func1()</span><br><span class="line"><span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">	<span class="comment">// 没有错误，继续执行流程</span></span><br><span class="line">	err = func2()</span><br><span class="line">	<span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// 没有错误，继续执行流程</span></span><br><span class="line">		err = func3()</span><br><span class="line">		<span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="comment">// 没有错误，继续执行流程</span></span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 有错误，处理错误</span></span><br><span class="line">	&#125;</span><br><span class="line">		<span class="comment">// 有错误，处理错误</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 有错误，处理错误</span></span><br></pre></td></tr></table></figure>

<p>这两种写法中第 1 种更合理，且可读性更好；第 2 种写法是糟糕的，代码有很多缩进块，可读性很差。人脑天生不适合去理解这种层层嵌套的东西（想想递归函数，你能往脑袋里压进所有的递归调用吗😂）。</p>
<h2 id="通过减少错误出现的次数的方式去减少错误处理的次数"><a href="#通过减少错误出现的次数的方式去减少错误处理的次数" class="headerlink" title="通过减少错误出现的次数的方式去减少错误处理的次数"></a>通过减少错误出现的次数的方式去减少错误处理的次数</h2><p>要这样子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AuthenticateRequest</span><span class="params">(r *Request)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> authenticate(r.User)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不要这样子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AuthenticateRequest</span><span class="params">(r *Request)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	err := authenticate(r.User)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>来看一个 Rob Pike 的例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">_, err = fd.Write(p0[a:b])</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">_, err = fd.Write(p1[c:d])</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">_, err = fd.Write(p2[e:f])</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// and so on</span></span><br></pre></td></tr></table></figure>

<p>这段代码有 3 个错误是否为 nil 的检查，这些重复、繁琐的代码让代码失去了优雅。应用同样的原理，这段代码可以优化为：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> errWriter <span class="keyword">struct</span> &#123;</span><br><span class="line">    w   io.Writer</span><br><span class="line">    err error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ew *errWriter)</span> <span class="title">write</span><span class="params">(buf []<span class="keyword">byte</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> ew.err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    _, ew.err = ew.w.Write(buf)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ew := &amp;errWriter&#123;w: fd&#125;</span><br><span class="line">ew.write(p0[a:b])</span><br><span class="line">ew.write(p1[c:d])</span><br><span class="line">ew.write(p2[e:f])</span><br><span class="line"><span class="comment">// and so on</span></span><br><span class="line"><span class="keyword">if</span> ew.err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ew.err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后得到的代码更加简洁、优雅。</p>
<h2 id="Only-handle-errors-once"><a href="#Only-handle-errors-once" class="headerlink" title="Only handle errors once"></a>Only handle errors once</h2><p>Dave Cheney 在中提到，我们只应该处理错误一次。处理错误意味着检查错误值并做出决定。这句话的意思每一次检查错误，我们只应该做出一个选择。</p>
<p>对于一个错误，如果你做出少于一次的选择（没有接收函数返回的 error，或者接收了但不处理），你就是在忽略错误。就像我们在这里看到的，<code>w.Write</code> 返回的错误没有被接收：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Write</span><span class="params">(w io.Writer, buf []<span class="keyword">byte</span>)</span></span> &#123;</span><br><span class="line">        w.Write(buf)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于一个错误，如果你做出多于一次的选择也是有问题的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Write</span><span class="params">(w io.Writer, buf []<span class="keyword">byte</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">        _, err := w.Write(buf)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="comment">// annotated error goes to log file</span></span><br><span class="line">                log.Println(<span class="string">&quot;unable to write:&quot;</span>, err)</span><br><span class="line"> </span><br><span class="line">                <span class="comment">// unannotated error returned to caller</span></span><br><span class="line">                <span class="keyword">return</span> err</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，如果 <code>w.Write</code> 返回了一个错误，那么代码会打印一条日志，接下来这个错误被返回给 <code>Write</code> 的调用者，而 <code>Write</code> 的调用者也有可能会做同样的操作：打印日志，然后继续向上透传。而调用者的调用者也做同样的事情，依次类推，直到达到调用链的开始。</p>
<p>这样我们得到了多余的、重复的日志打印，这是很糟糕的，无益于我们跟踪错误。而且在调用链的开始处，我们得到的是没有任何上下文的原始错误，导致我们无法判断错误是从调用链中的哪一个节点抛出的。<code>Wrap errors</code> 这个时候派上了用场：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Write</span><span class="params">(w io.Write, buf []<span class="keyword">byte</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">        _, err := w.Write(buf)</span><br><span class="line">        <span class="keyword">return</span> errors.Wrap(err, <span class="string">&quot;write failed&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 errors package，给错误添加上下文信息，这样程序员和机器都是很好地检查错误。</p>
<p>参考：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.golang.org/errors-are-values">Errors are values</a></li>
<li><a target="_blank" rel="noopener" href="https://dave.cheney.net/2016/04/27/dont-just-check-errors-handle-them-gracefully">Don’t just check errors, handle them gracefully</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.golang.org/error-handling-and-go">Error handling and Go</a></li>
<li><a target="_blank" rel="noopener" href="https://u.geekbang.org/subject/go">Go进阶训练营</a></li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/go/" rel="tag"># go</a>
              <a href="/tags/best-practice/" rel="tag"># best-practice</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/02/23/websocket-wrapper/" rel="prev" title="Go封装WebSocket，让开发WebSocket API变得更简单">
      <i class="fa fa-chevron-left"></i> Go封装WebSocket，让开发WebSocket API变得更简单
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Error-%E7%9A%84%E5%A4%84%E7%90%86%E7%AD%96%E7%95%A5"><span class="nav-number">1.</span> <span class="nav-text">Error 的处理策略</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Sentinel-errors"><span class="nav-number">1.1.</span> <span class="nav-text">Sentinel errors</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Error-types"><span class="nav-number">1.2.</span> <span class="nav-text">Error types</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Opaque-errors"><span class="nav-number">1.3.</span> <span class="nav-text">Opaque errors</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%A8%E9%87%8A%E9%94%99%E8%AF%AF"><span class="nav-number">1.3.1.</span> <span class="nav-text">注释错误</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Wrap-errors"><span class="nav-number">1.3.2.</span> <span class="nav-text">Wrap errors</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Wrap-errors-%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="nav-number">1.3.3.</span> <span class="nav-text">Wrap errors 最佳实践</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%AD%E8%A8%80%E9%94%99%E8%AF%AF%E7%9A%84%E8%A1%8C%E4%B8%BA%EF%BC%8C%E8%80%8C%E4%B8%8D%E6%98%AF%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.3.4.</span> <span class="nav-text">断言错误的行为，而不是类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#error-%E5%A4%84%E7%90%86%E5%BA%93%E7%9A%84%E9%80%89%E6%8B%A9"><span class="nav-number">1.3.5.</span> <span class="nav-text">error 处理库的选择</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Error-%E5%A4%84%E7%90%86%E6%8A%80%E5%B7%A7"><span class="nav-number">2.</span> <span class="nav-text">Error 处理技巧</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Fail-fast-%E5%B0%BD%E6%97%A9%E5%A4%84%E7%90%86%E9%94%99%E8%AF%AF"><span class="nav-number">2.1.</span> <span class="nav-text">Fail-fast: 尽早处理错误</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%9A%E8%BF%87%E5%87%8F%E5%B0%91%E9%94%99%E8%AF%AF%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0%E7%9A%84%E6%96%B9%E5%BC%8F%E5%8E%BB%E5%87%8F%E5%B0%91%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E7%9A%84%E6%AC%A1%E6%95%B0"><span class="nav-number">2.2.</span> <span class="nav-text">通过减少错误出现的次数的方式去减少错误处理的次数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Only-handle-errors-once"><span class="nav-number">2.3.</span> <span class="nav-text">Only handle errors once</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="破障者"
      src="/images/hotballoon.jpg">
  <p class="site-author-name" itemprop="name">破障者</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">7</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">破障者</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
